name: Deploy Apps Script

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install clasp
        run: npm i -g @google/clasp

      - name: Configure OAuth tokens for clasp
        env:
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          GOOGLE_REFRESH_TOKEN: ${{ secrets.GOOGLE_REFRESH_TOKEN }}
        run: |
          if [ -z "${GOOGLE_CLIENT_ID}" ] || [ -z "${GOOGLE_CLIENT_SECRET}" ] || [ -z "${GOOGLE_REFRESH_TOKEN}" ]; then
            echo "Missing one of GOOGLE_CLIENT_ID / GOOGLE_CLIENT_SECRET / GOOGLE_REFRESH_TOKEN secrets."
            exit 1
          fi
          cat > ~/.clasprc.json <<EOF
          {
            "token": {
              "access_token": "",
              "refresh_token": "${GOOGLE_REFRESH_TOKEN}",
              "scope": "https://www.googleapis.com/auth/script.deployments https://www.googleapis.com/auth/script.projects https://www.googleapis.com/auth/drive",
              "token_type": "Bearer",
              "expiry_date": 0
            },
            "oauth2ClientSettings": {
              "clientId": "${GOOGLE_CLIENT_ID}",
              "clientSecret": "${GOOGLE_CLIENT_SECRET}",
              "redirectUri": "http://localhost"
            },
            "isLocalCreds": false
          }
          EOF
          echo "Created ~/.clasprc.json"

      - name: Write .clasp.json from secret SCRIPT_ID
        env:
          GAS_SCRIPT_ID: ${{ secrets.GAS_SCRIPT_ID }}
        run: |
          if [ -z "${GAS_SCRIPT_ID}" ]; then
            echo "Missing GAS_SCRIPT_ID secret."
            exit 1
          fi
          cat > .clasp.json <<JSON
          {
            "scriptId": "${GAS_SCRIPT_ID}",
            "rootDir": "apps-script"
          }
          JSON
          cat .clasp.json
      - name: Inject SHEET_ID from secret (optional)
        env:
          GAS_SHEET_ID: ${{ secrets.GAS_SHEET_ID }}
        run: |
          if [ -n "${GAS_SHEET_ID}" ]; then
            echo "Injecting SHEET_ID into apps-script/Code.gs from GAS_SHEET_ID secret"
            sed -i "s|const SHEET_ID = 'PUT_SHEET_ID_HERE';|const SHEET_ID = '${GAS_SHEET_ID}';|g" apps-script/Code.gs
            grep -n "SHEET_ID" apps-script/Code.gs || true
          else
            echo "GAS_SHEET_ID not set; using repository value in Code.gs"
          fi

      - name: Inject BACKGROUND_URL from secret (optional)
        env:
          GAS_BACKGROUND_URL: ${{ secrets.GAS_BACKGROUND_URL }}
        run: |
          if [ -n "${GAS_BACKGROUND_URL}" ]; then
            echo "Injecting BACKGROUND_URL into apps-script/Code.gs from GAS_BACKGROUND_URL secret"
            # Escape '&' for sed replacement
            SAFE_URL="${GAS_BACKGROUND_URL//&/\\&}"
            # Replace whatever is on the right-hand side to make this robust
            sed -i "s|^const BACKGROUND_URL = .*|const BACKGROUND_URL = '${SAFE_URL}';|g" apps-script/Code.gs
            echo "Resolved BACKGROUND_URL line:"
            nl -ba apps-script/Code.gs | sed -n '1,20p' | grep -n \"BACKGROUND_URL\" || true
          else
            echo "GAS_BACKGROUND_URL not set; using repository value in Code.gs (fallback gradient will be used)."
          fi

      - name: Push source to Apps Script
        run: |
          clasp push -f
      # Only attempt deploy if all previous steps succeeded
      - name: Deploy web app (update existing deployment)
        if: ${{ success() }}
        env:
          GAS_DEPLOYMENT_ID: ${{ secrets.GAS_DEPLOYMENT_ID }}
        run: |
          if [ -z "${GAS_DEPLOYMENT_ID}" ]; then
            echo "ERROR: GAS_DEPLOYMENT_ID secret is required and must be the Web app Deployment ID (AKfy...)."
            exit 1
          fi
          # Sanity check: looks like a Web App id (starts with AKfy)
          case "${GAS_DEPLOYMENT_ID}" in
            AKfy*) echo "Using Web App deployment: ${GAS_DEPLOYMENT_ID}" ;;
            *) echo "ERROR: GAS_DEPLOYMENT_ID does not look like a Web App id (should start with AKfy)."; exit 1 ;;
          esac
          # Print a short suffix (not masked) for human verification across steps
          DEP_ID_LAST8="${GAS_DEPLOYMENT_ID:${#GAS_DEPLOYMENT_ID}-8}"
          echo "Target Web App deployment (last8): ${DEP_ID_LAST8}"
          echo "DEP_ID_LAST8=${DEP_ID_LAST8}" >> "$GITHUB_ENV"
          
          # Create a new script version explicitly and capture its number
          NEW_VER_RAW="$(clasp version "CI $(git rev-parse --short HEAD)")"
          echo "${NEW_VER_RAW}"
          NEW_VER="$(echo "${NEW_VER_RAW}" | grep -Eo '[0-9]+' | tail -1)"
          if [ -z "${NEW_VER}" ]; then
            echo "ERROR: Could not detect new Apps Script version number."
            exit 1
          fi
          echo "New Apps Script version: ${NEW_VER}"
          echo "NEW_VER=${NEW_VER}" >> "$GITHUB_ENV"
          # Update the existing Web App deployment to point to the new version
          clasp deploy -i "${GAS_DEPLOYMENT_ID}" -V "${NEW_VER}" -d "CI deploy $(git rev-parse --short HEAD)"

      - name: Show deployments (for debugging)
        if: ${{ success() }}
        env:
          DEP_ID_LAST8: ${{ env.DEP_ID_LAST8 }}
        run: |
          echo "Listing deployments after CI deploy:"
          clasp deployments
          if [ -n "${DEP_ID_LAST8}" ]; then
            echo ""
            echo "Looking for the target deployment by last8 (${DEP_ID_LAST8}):"
            clasp deployments | grep -n "${DEP_ID_LAST8}" || true
          fi

      - name: Enforce Web App only (remove API Executable facet)
        if: ${{ success() }}
        env:
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          GOOGLE_REFRESH_TOKEN: ${{ secrets.GOOGLE_REFRESH_TOKEN }}
          GAS_DEPLOYMENT_ID: ${{ secrets.GAS_DEPLOYMENT_ID }}
          NEW_VER: ${{ env.NEW_VER }}
        run: |
          set -e
          # Parse scriptId from .clasp.json
          SCRIPT_ID="$(grep -oE '\"scriptId\" *: *\"[^\"]+\"' .clasp.json | sed 's/.*: *\"//; s/\"$//')"
          echo "SCRIPT_ID: ${SCRIPT_ID}"
          sudo apt-get update -y && sudo apt-get install -y jq >/dev/null
          ACCESS_TOKEN="$(curl -s -X POST https://oauth2.googleapis.com/token \
            -d client_id="${GOOGLE_CLIENT_ID}" \
            -d client_secret="${GOOGLE_CLIENT_SECRET}" \
            -d refresh_token="${GOOGLE_REFRESH_TOKEN}" \
            -d grant_type=refresh_token | jq -r '.access_token')"
          if [ -z "${ACCESS_TOKEN}" ] || [ "${ACCESS_TOKEN}" = "null" ]; then
            echo "ERROR: Failed to obtain access token"
            exit 1
          fi
          echo "Patching deployment to WEB_APP only (version ${NEW_VER})..."
          PATCH_URL="https://script.googleapis.com/v1/projects/${SCRIPT_ID}/deployments/${GAS_DEPLOYMENT_ID}?updateMask=deploymentConfig.entryPoints,deploymentConfig.versionNumber"
          BODY="$(cat <<JSON
          {
            "deploymentConfig": {
              "versionNumber": ${NEW_VER},
              "entryPoints": [
                {
                  "entryPointType": "WEB_APP",
                  "webApp": {
                    "access": "ANYONE",
                    "executeAs": "USER_DEPLOYING"
                  }
                }
              ]
            }
          }
JSON
          )"
          echo "${BODY}" | jq .
          curl -s -X PATCH "${PATCH_URL}" \
            -H "Authorization: Bearer ${ACCESS_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "${BODY}" | jq .


